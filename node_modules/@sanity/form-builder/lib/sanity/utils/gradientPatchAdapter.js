'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _mutator = require('@sanity/mutator');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*:: import type {Patch} from '../../utils/patches'*/
/*:: type GradientPatch = Object*/
/*:: type Adapter = {
  fromFormBuilder: (patches: Array<Patch>) => Array<GradientPatch>,
  toFormBuilder: (origin: string, patches: Array<GradientPatch>) => Array<Patch>
}*/


const adapter /*: Adapter*/ = {
  fromFormBuilder(patches) {
    return patches.map(fromFormBuilder);
  },
  toFormBuilder
};

exports.default = adapter;

/**
 *
 * *** WARNING ***
 *
 * This function is *EXPERIMENTAL* and very likely to have bugs. It is not in real use yet, and needs
 * to be revised.
 */

function toFormBuilder(origin, patches /*: Array<GradientPatch>*/) /*: Array<Patch>*/ {
  return (0, _flatten3.default)(patches.map(patch => {
    return (0, _flatten3.default)(Object.keys(patch).filter(key => key !== 'id').map((type) /*: Array<Patch>*/ => {
      if (type === 'unset') {
        return patch.unset.map(path => {
          return {
            type: 'unset',
            path: path.split('.'),
            origin
          };
        });
      }
      return Object.keys(patch[type]).map(path => {
        if (type === 'insert') {
          const position = 'before' in patch.insert ? 'before' : 'after';
          return {
            type: 'insert',
            position: position,
            path: path.split('.'),
            items: patch[type][path],
            origin
          };
        }
        if (type === 'set') {
          return {
            type: 'set',
            path: path.split('.'),
            value: patch[type][path],
            origin
          };
        }
        return {
          type,
          path: path.split('.'),
          value: patch[type][path],
          origin
        };
      });
    }));
  }));
}

function fromFormBuilder(patch /*: Patch*/) /*: GradientPatch*/ {
  const matchPath = (0, _mutator.arrayToJSONMatchPath)(patch.path || []);
  if (patch.type === 'insert') {
    const position = patch.position,
          items = patch.items;

    return {
      insert: {
        [position]: matchPath,
        items: items
      }
    };
  }

  if (patch.type === 'unset') {
    return {
      unset: [matchPath]
    };
  }

  (0, _assert2.default)(patch.type, `Missing patch type in patch ${JSON.stringify(patch)}`);
  if (matchPath) {
    return {
      [patch.type]: {
        [matchPath]: patch.value
      }
    };
  }
  return {
    [patch.type]: patch.value
  };
}