'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _throttle2 = require('lodash/throttle');

var _throttle3 = _interopRequireDefault(_throttle2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
// Connects the FormBuilder with various sanity roles


var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

var _draftUtils = require('../utils/draftUtils');

var _formBuilder = require('part:@sanity/form-builder');

var _formBuilder2 = _interopRequireDefault(_formBuilder);

var _Editor = require('./Editor');

var _Editor2 = _interopRequireDefault(_Editor);

var _schema = require('part:@sanity/base/schema');

var _schema2 = _interopRequireDefault(_schema);

var _default = require('part:@sanity/components/buttons/default');

var _default2 = _interopRequireDefault(_default);

var _client = require('part:@sanity/base/client');

var _client2 = _interopRequireDefault(_client);

var _EditorWrapper = require('./styles/EditorWrapper.css');

var _EditorWrapper2 = _interopRequireDefault(_EditorWrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INITIAL_DOCUMENT_STATE = {
  isLoading: true,
  deletedSnapshot: null,
  snapshot: null
};

const INITIAL_STATE = {
  isSaving: true,
  isCreatingDraft: false,
  transactionResult: null,
  draft: INITIAL_DOCUMENT_STATE,
  published: INITIAL_DOCUMENT_STATE
};

function documentEventToState(event) {
  switch (event.type) {
    case 'rebase':
    case 'create':
    case 'createIfNotExists':
    case 'snapshot':
      {
        return {
          deletedSnapshot: null,
          snapshot: event.document
        };
      }
    case 'mutation':
      {
        return {
          deletedSnapshot: event.deletedSnapshot,
          snapshot: event.document ? _extends({}, event.document, {
            // todo: The following line is a temporary workaround for a problem with the mutator not
            // setting updatedAt on patches applied optimistic when they are received from server
            // can be removed when this is fixed
            _updatedAt: new Date().toISOString()
          }) : event.document
        };
      }
    default:
      {
        // eslint-disable-next-line no-console
        console.log('Unhandled document event type "%s"', event.type, event);
        return {};
      }
  }
}

function exists(draft, published) {
  return draft.snapshot || published.snapshot;
}

function isRecoverable(draft, published) {
  return !exists(draft, published) && (draft.deletedSnapshot || published.deletedSnapshot);
}

class EditorPane extends _react2.default.Component {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.state = INITIAL_STATE, this.patchChannel = _formBuilder2.default.createPatchChannel(), this.receiveDraftEvent = event => {
      if (event.type !== 'mutation') {
        return;
      }
      // Broadcast incoming patches to input components that applies patches on their own
      // Note: This is *experimental*
      this.patchChannel.receivePatches({
        patches: event.patches,
        snapshot: event.document
      });
    }, this.handleDiscardDraft = () => {
      this.draft.delete();
      this.draft.commit().subscribe(() => {
        // todo: error handling
      });
    }, this.handleDelete = () => {
      const documentId = this.props.documentId;

      const tx = _client2.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId)).delete((0, _draftUtils.getDraftId)(documentId));

      _observable2.default.from(tx.commit()).map(result => ({
        type: 'success',
        result: result
      })).catch(error => _observable2.default.of({
        type: 'error',
        message: `An error occurred while attempting to delete document.
        This usually means that you attempted to delete a document that other documents
        refers to.`,
        error
      })).subscribe(result => {
        this.setState({ transactionResult: result });
      });
    }, this.handleClearTransactionResult = () => {
      this.setState({ transactionResult: null });
    }, this.handleUnpublish = () => {
      const documentId = this.props.documentId;
      const published = this.state.published;


      let tx = _client2.default.observable.transaction().delete((0, _draftUtils.getPublishedId)(documentId));

      if (published.snapshot) {
        tx = tx.createIfNotExists(_extends({}, (0, _omit3.default)(published.snapshot, '_updatedAt'), {
          _id: (0, _draftUtils.getDraftId)(documentId)
        }));
      }

      _observable2.default.from(tx.commit()).map(result => ({
        type: 'success',
        result: result
      })).catch(error => _observable2.default.of({
        type: 'error',
        message: `An error occurred while attempting to unpublish document.
        This usually means that you attempted to unpublish a document that other documents
        refers to.`,
        error
      })).subscribe(result => {
        this.setState({ transactionResult: result });
      });
    }, this.handlePublish = () => {
      const documentId = this.props.documentId;
      const draft = this.state.draft;

      this.setState({ isPublishing: true });

      const tx = _client2.default.observable.transaction().createOrReplace(_extends({}, (0, _omit3.default)(draft.snapshot, '_updatedAt'), {
        _id: (0, _draftUtils.getPublishedId)(documentId)
      })).delete((0, _draftUtils.getDraftId)(documentId));

      _observable2.default.from(tx.commit()).map(result => ({
        type: 'success',
        result: result
      })).catch(error => _observable2.default.of({
        type: 'error',
        message: 'An error occurred while attempting to publishing document',
        error
      })).subscribe({
        next: result => {
          this.setState({
            transactionResult: result
          });
        },
        complete: () => {
          this.setState({ isPublishing: false });
        }
      });
    }, this.handleChange = event => {
      var _state = this.state;
      const published = _state.published,
            draft = _state.draft;
      const typeName = this.props.typeName;


      if (!draft.snapshot) {
        this.draft.createIfNotExists(_extends({}, (0, _omit3.default)(published.snapshot, '_updatedAt'), {
          _id: this.getDraftId(),
          _type: typeName
        }));
      }

      this.draft.patch(event.patches);
      this.commit();
    }, this.commit = (0, _throttle3.default)(() => {
      this.setState({ isSaving: true });
      this.draft.commit().subscribe({
        next: () => {
          // todo
        },
        error: _error => {
          // todo
        },
        complete: () => {
          this.setState({ isSaving: false });
        }
      });
    }, 1000, { leading: true, trailing: true }), this.handleRestoreDeleted = () => {
      var _state2 = this.state;
      const draft = _state2.draft,
            published = _state2.published;


      const commits = [];
      if (draft.deletedSnapshot) {
        this.draft.createIfNotExists(draft.deletedSnapshot);
        commits.push(this.draft.commit());
      } else if (published.deletedSnapshot) {
        this.published.createIfNotExists(published.deletedSnapshot);
        commits.push(this.published.commit());
      }
      commits.forEach(c => {
        c.subscribe({
          next: () => {}
        });
      });
    }, _temp;
  }

  setup(documentId) {
    this.dispose();
    this.published = (0, _formBuilder.checkout)((0, _draftUtils.getPublishedId)(documentId));
    this.draft = (0, _formBuilder.checkout)((0, _draftUtils.getDraftId)(documentId));

    this.subscription = this.published.events.map(event => _extends({}, event, { version: 'published' })).merge(this.draft.events.do(this.receiveDraftEvent).map(event => _extends({}, event, { version: 'draft' }))).subscribe(event => {
      this.setState(prevState => {
        const version = event.version; // either 'draft' or 'published'
        return {
          [version]: _extends({}, prevState[version] || {}, documentEventToState(event), {
            isLoading: false
          })
        };
      });
    });
  }

  getDraftId() {
    return (0, _draftUtils.getDraftId)(this.props.documentId);
  }

  getPublishedId() {
    return (0, _draftUtils.getPublishedId)(this.props.documentId);
  }

  componentDidMount() {
    this.setup(this.props.documentId);
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.documentId !== this.props.documentId) {
      this.setState(INITIAL_STATE);
      this.setup(nextProps.documentId);
    }
  }

  componentWillUnmount() {
    this.dispose();
  }

  dispose() {
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = null;
    }
    this.published = null;
    this.draft = null;
  }

  renderDeleted() {
    return _react2.default.createElement(
      'div',
      { className: _EditorWrapper2.default.deletedDocument },
      _react2.default.createElement(
        'div',
        { className: _EditorWrapper2.default.deletedDocumentInner },
        _react2.default.createElement(
          'h3',
          null,
          'This document just got deleted'
        ),
        _react2.default.createElement(
          'p',
          null,
          'You can undo deleting it until you close this window/tab'
        ),
        _react2.default.createElement(
          _default2.default,
          { onClick: this.handleRestoreDeleted },
          'Undo delete'
        )
      )
    );
  }

  render() {
    const typeName = this.props.typeName;
    var _state3 = this.state;
    const draft = _state3.draft,
          published = _state3.published,
          isCreatingDraft = _state3.isCreatingDraft,
          isUnpublishing = _state3.isUnpublishing,
          transactionResult = _state3.transactionResult,
          isPublishing = _state3.isPublishing,
          isSaving = _state3.isSaving;


    if (isRecoverable(draft, published)) {
      return this.renderDeleted();
    }

    return _react2.default.createElement(_Editor2.default, {
      patchChannel: this.patchChannel,
      type: _schema2.default.get(typeName),
      published: published.snapshot,
      draft: draft.snapshot,
      isLoading: draft.isLoading || published.isLoading,
      isSaving: isSaving,
      isPublishing: isPublishing,
      isUnpublishing: isUnpublishing,
      transactionResult: transactionResult,
      isCreatingDraft: isCreatingDraft,
      onDelete: this.handleDelete,
      onClearTransactionResult: this.handleClearTransactionResult,
      onDiscardDraft: this.handleDiscardDraft,
      onPublish: this.handlePublish,
      onUnpublish: this.handleUnpublish,
      onChange: this.handleChange
    });
  }
}
exports.default = EditorPane;
EditorPane.propTypes = {
  documentId: _propTypes2.default.string.isRequired,
  typeName: _propTypes2.default.string.isRequired
};