'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _uniq2 = require('lodash/uniq');

var _uniq3 = _interopRequireDefault(_uniq2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = createPathMaterializer;

var _observable = require('@sanity/observable');

var _observable2 = _interopRequireDefault(_observable);

var _observableProps = require('observable-props');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

const props = (0, _observableProps.configure)({ Observable: _observable2.default });

function isReference(value) {
  return '_ref' in value;
}

function isDocument(value) {
  return '_id' in value;
}

function createEmpty(keys) {
  return keys.reduce((result, key) => {
    result[key] = undefined;
    return result;
  }, {});
}

function resolveMissingHeads(value, paths) {
  return paths.filter(path => !(path[0] in value));
}

function createPathMaterializer(observeWithPaths) {
  return function materializePaths(value, paths) {
    if (!(0, _isArray3.default)(value) && !(0, _isObject3.default)(value)) {
      // Reached a leaf. Don't blow up
      return _observable2.default.of(value);
    }
    const missingHeads = resolveMissingHeads(value, paths);
    if (missingHeads.length > 0) {
      // Reached a node that is either a document (with _id), or a reference (with _ref) that
      // needs to be "materialized"

      const nextHeads = (0, _uniq3.default)(missingHeads.map(path => [path[0]]));

      if (isReference(value) || isDocument(value)) {
        const id = isReference(value) ? value._ref : value._id;
        return observeWithPaths(id, nextHeads).switchMap(snapshot => {
          return materializePaths(_extends({}, createEmpty(nextHeads), value, snapshot), paths);
        });
      }
    }

    const leads = {};
    paths.forEach(path => {
      var _path = _toArray(path);

      const head = _path[0],
            tail = _path.slice(1);

      if (!leads[head]) {
        leads[head] = [];
      }
      leads[head].push(tail);
    });

    const next = Object.keys(leads).reduce((res, head) => {
      const tails = leads[head];
      if (tails.every(tail => tail.length === 0)) {
        res[head] = value[head];
      } else {
        res[head] = materializePaths(value[head], tails);
      }
      return res;
    }, _extends({}, value));

    return props(_observable2.default.of(next), { wait: true });
  };
}