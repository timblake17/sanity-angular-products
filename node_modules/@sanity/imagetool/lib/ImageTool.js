'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _getBackingStoreRatio = require('./getBackingStoreRatio');

var _getBackingStoreRatio2 = _interopRequireDefault(_getBackingStoreRatio);

var _makeDragAware = require('./makeDragAware');

var _makeDragAware2 = _interopRequireDefault(_makeDragAware);

var _utils = require('./2d/utils');

var utils2d = _interopRequireWildcard(_utils);

var _shapes = require('./2d/shapes');

var _cursors = require('./cursors');

var cursors = _interopRequireWildcard(_cursors);

var _constants = require('./constants');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DragAwareCanvas = (0, _makeDragAware2.default)('canvas');

// The margin available in all directions for drawing the crop tool
const MARGIN_PX = 8;
const CROP_HANDLE_SIZE = 12;
const HOTSPOT_HANDLE_SIZE = 10;

function getCropCursorForHandle(handle) {
  switch (handle) {
    case 'left':
    case 'right':
      return 'col-resize';

    case 'top':
    case 'bottom':
      return 'row-resize';

    case 'topRight':
    case 'bottomLeft':
      return 'nesw-resize';

    case 'topLeft':
    case 'bottomRight':
      return 'nwse-resize';
    default:
      return null;
  }
}

class ImageTool extends _react2.default.PureComponent {
  constructor(...args) {
    var _temp;

    return _temp = super(...args), this.state = {
      devicePixelVsBackingStoreRatio: null,
      cropping: false,
      cropMoving: false,
      moving: false
    }, this.handleDragStart = ({ x, y }) => {
      const mousePosition = { x: x * this.getScale(), y: y * this.getScale() };

      const inHotspot = utils2d.isPointInEllipse(mousePosition, this.getHotspotRect());

      const inDragHandle = utils2d.isPointInCircle(mousePosition, this.getDragHandleCoords());

      const activeCropHandle = this.getActiveCropHandleFor(mousePosition);

      const inCropRect = utils2d.isPointInRect(mousePosition, this.getCropRect());

      if (activeCropHandle) {
        this.setState({ cropping: activeCropHandle });
      } else if (inDragHandle) {
        this.setState({ resizing: true });
      } else if (inHotspot) {
        this.setState({ moving: true });
      } else if (inCropRect) {
        this.setState({ cropMoving: true });
      }
    }, this.handleDrag = pos => {
      if (this.state.cropping) {
        this.emitCrop(this.state.cropping, pos);
      } else if (this.state.cropMoving) {
        this.emitCropMove(pos);
      } else if (this.state.moving) {
        this.emitMove(pos);
      } else if (this.state.resizing) {
        this.emitResize(pos);
      }
    }, this.handleDragEnd = pos => {
      var _props = this.props;
      const onChange = _props.onChange,
            onChangeEnd = _props.onChangeEnd;

      this.setState({ moving: false, resizing: false, cropping: false, cropMoving: false });

      var _getClampedValue = this.getClampedValue();

      const hotspot = _getClampedValue.hotspot,
            crop = _getClampedValue.crop;


      const finalValue = {
        crop: {
          top: crop.top,
          bottom: 1 - crop.bottom,
          left: crop.left,
          right: 1 - crop.right
        },
        hotspot: {
          x: hotspot.center.x,
          y: hotspot.center.y,
          height: Math.abs(hotspot.height),
          width: Math.abs(hotspot.width)
        }
      };
      onChange(finalValue);
      if (onChangeEnd) {
        onChangeEnd();
      }
    }, this.handleMouseOut = () => {
      this.setState({ mousePosition: null });
    }, this.handleMouseMove = event => {
      const clientRect = event.target.getBoundingClientRect();
      this.setState({
        mousePosition: {
          x: (event.clientX - clientRect.left) * this.getScale(),
          y: (event.clientY - clientRect.top) * this.getScale()
        }
      });
    }, this.setCanvas = node => {
      this.canvas = node;
    }, _temp;
  }

  getHotspotRect() {
    var _props2 = this.props;
    const value = _props2.value,
          image = _props2.image;


    const hotspot = value.hotspot || _constants.DEFAULT_HOTSPOT;
    const hotspotRect = new _shapes.Rect().setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y);

    return new _shapes.Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale()).multiply(hotspotRect);
  }

  getCropRect() {
    var _props3 = this.props;
    const value = _props3.value,
          image = _props3.image;


    return new _shapes.Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale()).cropRelative(_shapes.Rect.fromEdges(value.crop || _constants.DEFAULT_CROP).clamp(new _shapes.Rect(0, 0, 1, 1)));
  }

  getCropHandles() {

    const inner = this.getCropRect();

    const handleSize = CROP_HANDLE_SIZE * this.getScale();

    const halfCropHandleSize = handleSize / 2;

    const cropHandle = new _shapes.Rect(0, 0, handleSize, handleSize);
    return {
      left: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.center.y - halfCropHandleSize),
      right: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.center.y - halfCropHandleSize),

      top: cropHandle.setTopLeft(inner.center.x - halfCropHandleSize, inner.top - halfCropHandleSize),
      topLeft: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.top - halfCropHandleSize),
      topRight: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.top - halfCropHandleSize),

      bottom: cropHandle.setTopLeft(inner.center.x - halfCropHandleSize, inner.bottom - halfCropHandleSize),
      bottomLeft: cropHandle.setTopLeft(inner.left - halfCropHandleSize, inner.bottom - halfCropHandleSize),
      bottomRight: cropHandle.setTopLeft(inner.right - halfCropHandleSize, inner.bottom - halfCropHandleSize)
    };
  }

  getActiveCropHandleFor({ x, y }) {
    const cropHandles = this.getCropHandles();

    return Object.keys(cropHandles).find(position => {
      return utils2d.isPointInRect({ x, y }, cropHandles[position]);
    });
  }

  applyHotspotMoveBy(value, delta) {
    const currentHotspot = value && value.hotspot || _constants.DEFAULT_HOTSPOT;
    return Object.assign({}, value, {
      hotspot: Object.assign({}, value.hotspot, {
        x: currentHotspot.x + delta.x,
        y: currentHotspot.y + delta.y
      })
    });
  }

  applyHotspotResizeBy(value, delta) {
    const currentHotspot = value && value.hotspot || _constants.DEFAULT_HOTSPOT;
    return Object.assign({}, value, {
      hotspot: Object.assign({}, currentHotspot, {
        height: currentHotspot.height + delta.height,
        width: currentHotspot.width + delta.width
      })
    });
  }

  applyCropMoveBy(value, delta) {
    const currentCrop = value && value.crop || _constants.DEFAULT_CROP;
    return Object.assign({}, value, {
      crop: Object.assign({}, value.crop, {
        left: currentCrop.left + (delta.left || 0),
        right: currentCrop.right + (delta.right || 0),
        top: currentCrop.top + (delta.top || 0),
        bottom: currentCrop.bottom + (delta.bottom || 0)
      })
    });
  }

  emitMove(pos) {
    var _props4 = this.props;
    const image = _props4.image,
          value = _props4.value,
          onChange = _props4.onChange;

    const scale = this.getScale();
    const delta = {
      x: pos.x * scale / image.width,
      y: pos.y * scale / image.height
    };

    onChange(this.applyHotspotMoveBy(value, delta));
  }

  emitCropMove(pos) {
    var _props5 = this.props;
    const image = _props5.image,
          onChange = _props5.onChange,
          value = _props5.value;

    const scale = this.getScale();
    const delta = {};
    delta.left = pos.x * scale / image.width;
    delta.right = -pos.x * scale / image.width;

    delta.top = pos.y * scale / image.height;
    delta.bottom = -pos.y * scale / image.height;

    onChange(this.applyCropMoveBy(value, delta));
  }

  emitCrop(side, pos) {
    var _props6 = this.props;
    const image = _props6.image,
          onChange = _props6.onChange,
          value = _props6.value;

    const scale = this.getScale();
    const delta = {};

    if (side == 'left' || side === 'topLeft' || side === 'bottomLeft') {
      delta.left = pos.x * scale / image.width;
    } else if (side == 'right' || side === 'topRight' || side === 'bottomRight') {
      delta.right = -pos.x * scale / image.width;
    }

    if (side == 'top' || side === 'topLeft' || side === 'topRight') {
      delta.top = pos.y * scale / image.height;
    } else if (side == 'bottom' || side === 'bottomLeft' || side === 'bottomRight') {
      delta.bottom = -pos.y * scale / image.height;
    }

    onChange(this.applyCropMoveBy(value, delta));
  }

  emitResize(pos) {
    var _props7 = this.props;
    const image = _props7.image,
          onChange = _props7.onChange,
          value = _props7.value;

    const scale = this.getScale();

    const delta = {
      x: pos.x * scale * 2 / image.width,
      y: pos.y * scale * 2 / image.height
    };
    onChange(this.applyHotspotResizeBy(value, { height: delta.y, width: delta.x }));
  }

  componentDidMount() {
    this.setState({
      devicePixelVsBackingStoreRatio: this.getDevicePixelVsBackingStoreRatio(this.canvas.domNode.getContext('2d'))
    });
  }

  getDevicePixelVsBackingStoreRatio(context) {
    const devicePixelRatio = window.devicePixelRatio || 1;
    const backingStoreRatio = (0, _getBackingStoreRatio2.default)(context) || 1;
    return devicePixelRatio / backingStoreRatio;
  }

  getClampedValue() {
    const value = this.props.value;

    const crop = _shapes.Rect.fromEdges(value.crop || _constants.DEFAULT_CROP).clamp(new _shapes.Rect(0, 0, 1, 1));

    const hotspot = value.hotspot || _constants.DEFAULT_HOTSPOT;
    const hotspotRect = new _shapes.Rect(0, 0, 1, 1).setSize(hotspot.width, hotspot.height).setCenter(hotspot.x, hotspot.y).clamp(crop);

    return { crop: crop, hotspot: hotspotRect };
  }

  paintHotspot(context) {
    const image = this.props.image;


    const imageRect = new _shapes.Rect().setSize(image.width, image.height);

    var _getClampedValue2 = this.getClampedValue();

    const hotspot = _getClampedValue2.hotspot,
          crop = _getClampedValue2.crop;


    const scale = this.getScale();
    const margin = MARGIN_PX * scale;

    context.save();
    drawBackdrop();
    drawEllipse();
    context.clip();
    drawHole();
    context.restore();
    drawDragHandle(Math.PI * 1.25);

    function drawEllipse() {
      context.save();

      const dest = imageRect.shrink(margin).multiply(hotspot);

      const scaleY = dest.height / dest.width;

      context.scale(1, scaleY);
      context.beginPath();
      context.globalAlpha = 0.8;
      context.arc(dest.center.x, dest.center.y / scaleY, Math.abs(dest.width / 2), 0, 2 * Math.PI, false);
      context.strokeStyle = 'white';
      context.lineWidth = 1.5 * scale;
      context.stroke();
      context.closePath();

      context.restore();
    }

    function drawImage(...args) {
      context.save();
      context.drawImage(image, ...args);
      context.restore();
    }

    function drawHole() {

      const src = imageRect.multiply(hotspot);

      const dest = imageRect.shrink(margin).multiply(hotspot);

      drawImage(src.left, src.top, src.width, src.height, dest.left, dest.top, dest.width, dest.height);
    }

    function drawBackdrop() {

      const src = imageRect.cropRelative(crop);

      const dest = imageRect.shrink(margin).cropRelative(crop);

      context.save();
      drawImage(src.left, src.top, src.width, src.height, dest.left, dest.top, dest.width, dest.height);
      context.globalAlpha = 0.5;
      context.fillStyle = 'black';
      context.fillRect(dest.left, dest.top, dest.width, dest.height);
      context.restore();
    }

    function drawDragHandle(radians) {
      context.save();

      const radius = HOTSPOT_HANDLE_SIZE * scale;
      const dest = imageRect.shrink(margin).multiply(hotspot);

      const point = utils2d.getPointAtCircumference(radians, dest);

      context.beginPath();
      context.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);
      context.fillStyle = 'rgb(255,255,255)';
      context.fill();
      context.closePath();
      context.restore();

      context.beginPath();
      context.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);
      context.strokeStyle = 'rgb(0, 0, 0)';
      context.lineWidth = 0.5 * scale;
      context.stroke();
      context.closePath();
    }
  }

  getActualSize() {
    const node = this.canvas.domNode;
    return { height: node.clientHeight, width: node.clientWidth };
  }

  getDragHandleCoords() {
    const bbox = this.getHotspotRect();
    const point = utils2d.getPointAtCircumference(Math.PI * 1.25, bbox);
    return {
      x: point.x,
      y: point.y,
      radius: 8 * this.getScale()
    };
  }

  debug(context) {
    context.save();

    const image = this.props.image;


    const bbox = this.getHotspotRect();
    const scale = this.getScale();
    const margin = MARGIN_PX * scale;

    // IE 10 doesn't support context.setLineDash
    if (context.setLineDash) {
      context.setLineDash([2 * scale, 2 * scale]);
    }
    context.lineWidth = 0.5 * scale;

    context.strokeStyle = 'rgba(200, 200, 200, 0.5)';

    // --- center line x
    vline(bbox.center.x);
    // --- center line y
    hline(bbox.center.y);

    context.strokeStyle = 'rgba(150, 150, 150, 0.5)';
    // --- line top
    hline(bbox.top);

    // --- line bottom
    hline(bbox.bottom);

    // --- line left
    vline(bbox.left);
    // --- line right
    vline(bbox.right);

    context.restore();

    function vline(x) {
      line(x, margin, x, image.height - margin);
    }

    function hline(y) {
      line(margin, y, image.width - margin, y);
    }

    function line(x1, y1, x2, y2) {
      context.beginPath();
      context.moveTo(x1, y1);
      context.lineTo(x2, y2);
      context.stroke();
      context.closePath();
    }
  }

  paintBackground(context) {
    const image = this.props.image;

    const inner = new _shapes.Rect().setSize(image.width, image.height).shrink(MARGIN_PX * this.getScale());

    context.save();
    context.fillStyle = 'white';
    context.clearRect(0, 0, image.width, image.height);

    context.globalAlpha = 0.3;
    //context.globalCompositeOperation = 'lighten';

    context.drawImage(image, inner.left, inner.top, inner.width, inner.height);
    context.restore();
  }

  paint(context) {
    context.save();

    const pxratio = this.state.devicePixelVsBackingStoreRatio;
    context.scale(pxratio, pxratio);

    this.paintBackground(context);
    //return context.restore();
    this.paintHotspot(context);
    //this.paintDragHandle(context);
    this.debug(context);
    this.paintCropBorder(context);

    if (this.state.mousePosition) {
      //this.paintMousePosition(context)
      this.highlightCropHandles(context);
    }

    context.restore();
  }

  paintMousePosition(context) {
    var _state$mousePosition = this.state.mousePosition;
    const x = _state$mousePosition.x,
          y = _state$mousePosition.y;

    context.beginPath();
    context.arc(x, y, 14 * this.getScale(), 0, 2 * Math.PI, false);
    context.fillStyle = 'lightblue';
    context.fill();
    context.restore();
  }

  paintCropBorder(context) {
    const cropRect = this.getCropRect();
    context.save();
    context.beginPath();
    context.fillStyle = 'rgba(66, 66, 66, 0.9)';
    context.lineWidth = 1;
    context.rect(cropRect.left, cropRect.top, cropRect.width, cropRect.height);
    context.stroke();
    context.closePath();
    context.restore();
  }

  highlightCropHandles(context) {
    context.save();
    const crophandles = this.getCropHandles();

    //context.globalCompositeOperation = "difference";

    Object.keys(crophandles).forEach(handle => {
      context.fillStyle = this.state.cropping === handle ? 'rgba(202, 54, 53, 0.9)' : 'rgba(230, 230, 230, 0.9)';
      var _crophandles$handle = crophandles[handle];
      const left = _crophandles$handle.left,
            top = _crophandles$handle.top,
            height = _crophandles$handle.height,
            width = _crophandles$handle.width;

      context.fillRect(left, top, width, height);
      context.beginPath();
      context.fillStyle = 'rgba(66, 66, 66, 0.9)';
      context.rect(left, top, width, height);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }

  getScale() {
    const actualSize = this.getActualSize();
    return this.props.image.width / actualSize.width;
  }

  getCursor() {
    const mousePosition = this.state.mousePosition;

    if (!mousePosition) {
      return 'auto';
    }

    const activeCropArea = this.state.cropping || this.getActiveCropHandleFor(mousePosition);
    if (activeCropArea) {
      return getCropCursorForHandle(activeCropArea);
    }

    const mouseOverDragHandle = utils2d.isPointInCircle(mousePosition, this.getDragHandleCoords());

    if (this.state.resizing || mouseOverDragHandle) {
      return 'move';
    }

    if (this.state.moving || this.state.cropMoving) {
      return `url(${cursors.CLOSE_HAND}), move`;
    }

    const mouseoverHotspot = utils2d.isPointInEllipse(mousePosition, this.getHotspotRect());
    const mouseoverCropRect = utils2d.isPointInRect(mousePosition, this.getCropRect());
    if (mouseoverHotspot || mouseoverCropRect) {
      return `url(${cursors.OPEN_HAND}), move`;
    }
    return 'auto';
  }

  componentDidUpdate() {
    const domNode = this.canvas.domNode;
    const context = domNode.getContext('2d');
    this.paint(context);
    const currentCursor = domNode.style.cursor;
    const newCursor = this.getCursor();
    if (currentCursor != newCursor) {
      domNode.style.cursor = newCursor;
    }
  }

  render() {
    var _props$image = this.props.image;
    const height = _props$image.height,
          width = _props$image.width;

    const ratio = this.state.devicePixelVsBackingStoreRatio;
    const style = {
      maxWidth: '100%',
      maxHeight: '100%',
      userSelect: 'none'
      // ,outline: '1px dotted cyan'
    };
    return _react2.default.createElement(DragAwareCanvas, {
      ref: this.setCanvas,
      onDrag: this.handleDrag,
      onDragStart: this.handleDragStart,
      onDragEnd: this.handleDragEnd,
      onMouseMove: this.handleMouseMove,
      onMouseOut: this.handleMouseOut,
      style: style,
      height: height * ratio,
      width: width * ratio
    });
  }
}
exports.default = ImageTool;
ImageTool.propTypes = {
  value: _propTypes2.default.shape({
    hotspot: _propTypes2.default.shape({
      x: _propTypes2.default.number,
      y: _propTypes2.default.number,
      height: _propTypes2.default.number,
      width: _propTypes2.default.number
    })
  }),
  image: _propTypes2.default.shape({
    height: _propTypes2.default.number,
    width: _propTypes2.default.number
  }),
  onChange: _propTypes2.default.func,
  onChangeEnd: _propTypes2.default.func
};
ImageTool.defaultProps = {
  onChange() {},
  onChangeEnd() {}
};